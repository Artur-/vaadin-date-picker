<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-list/iron-list.html">

<dom-module id="vaadin-infinite-scroller">
  <template>
    <style>
      :host {
        height: 500px;
        display: block;
      }

      #scroller {
        overflow: hidden;
        height: 100%;
      }

      #list {
        height: 100%;
        width: 100%;
        padding-right: 40px;
        margin-right: -40px;
        transform: none !important;
      }

      #list[notouchscroll] {
        -webkit-overflow-scrolling: auto !important;
      }
    </style>

    <div id="scroller">
      <iron-list id="list" items="[[_getActiveIndexes(active)]]" scroller-height="[[scrollerHeight]]" item-height="[[itemHeight]]" on-scroll="_onListScroll"></iron-list>
    </div>
  </template>
  <script>
    Polymer({
      is: 'vaadin-infinite-scroller',

      properties: {

        _indexes: {
          value: function() {
            var indexes = [];
            for (var i = 0; i < 10000; i++) {
              indexes[i] = i;
            }
            return indexes;
          }
        },

        _originIndex: Number,

        active: {
          type: Boolean,
          value: false
        },

        itemHeight: Number,

        scrollerHeight: Number

      },

      _getActiveIndexes: function(active) {
        this.async(function() { // TODO: Place!
          this._patchMetrics();
        }, 1000);

        return active ? this._indexes : [];
      },

      _getScaledPosition: function(physicalPosition) {
        return physicalPosition + (this._originIndex || 0);
      },

      _patchMetrics: function() {
        // Iron-list constantly measures the items' height which is an expensive
        // operation. We'll redefine offsetHeight here to avoid (in this case
        // unnecessary) measuring.
        this.$.list._physicalItems.forEach(function(item) {
          try {
            Object.defineProperty(item, "offsetHeight", {
              get: function() {
                return this.itemHeight;
              }.bind(this)
            });
          } catch (err) {
            // Ignore, default works fine
          }
        }, this);

        // TODO: Patch viewport offsetheight
      },

      ready: function() {
        this.async(function() {
          var template = Polymer.dom(this).querySelector('template');
          Polymer.dom(this.$.list).appendChild(template);
        });
      },

      _onListScroll: function() {
        if (this.$.list.firstVisibleIndex < this._indexes.length * 0.15 ||
          this.$.list.firstVisibleIndex > this._indexes.length * 0.85) {
          this.debounce('reset', this._reset, 100);
        }

        if (!this._preventScrollEvent) {
          this.fire('infinite-scroll');
          this._mayHaveMomentum = true;
        }
        this._preventScrollEvent = false;
      },

      _reset: function() {
        this._originIndex = -this._indexes.length / 2 + Math.round(this.position);
        for (var i = 0; i < this._indexes.length; i++) {
          this._indexes[i] = (this._originIndex + i).toString();
        }
        this.$.list.scrollToIndex(this._indexes.length / 2);
      },

      set position(position) {
        this._preventScrollEvent = true;
        if (position > this._originIndex && position < this._originIndex + this._indexes.length) {
          this.$.list.scrollToIndex(~~position - this._originIndex);
          this.$.list.scrollTop += position % 1 * this.itemHeight;
          // this.$.list.scrollTop = (position - this._originIndex) * this.itemHeight; Simpler, but doesn't keep up nicely
        } else {
          this._originIndex = position - this._indexes.length / 2;
          this._reset();
          this.position = position;
        }

        if (this._mayHaveMomentum) {
          // Stop the possible iOS Safari momentum with -webkit-overflow-scrolling: auto;
          this.$.list.toggleAttribute('notouchscroll', true);
          this._mayHaveMomentum = false;

          this.async(function() {
            // Restore -webkit-overflow-scrolling: touch; after a small delay.
            this.$.list.toggleAttribute('notouchscroll', false);
          }, 10);
        }
      },

      get position() {
        var list = this.$.list;
        // Need to access private variables :(
        var top = list._physicalTop;
        var start = list._virtualStart;
        var pos = list._scrollPosition;
        return this._getScaledPosition(start + (pos - top) / this.itemHeight);
      }


    });
  </script>
</dom-module>
